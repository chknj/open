<!doctype html>
<html lang="ko">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>이미지 최적화 | 확장자 변환</title>
        <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%23FFD24D' stroke='%23000' stroke-width='4'/><circle cx='35' cy='40' r='6' fill='%23000'/><circle cx='65' cy='40' r='6' fill='%23000'/><path d='M30 60 Q50 75 70 60' stroke='%23000' stroke-width='5' fill='none' stroke-linecap='round'/></svg>" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500&display=swap" rel="stylesheet" />
        <style>
            :root {
                color-scheme: light;
                --ink: #111111;
                --muted: #5a5a5a;
                --surface: #ffffff;
                --surface-alt: #f2f2f2;
                --accent: #4f4f4f;
                --accent-dark: #2a2a2a;
                --accent-soft: #e3e3e3;
                --line: #d6d6d6;
                --success: #1a7f37;
                --shadow: 0 20px 60px rgba(0, 0, 0, 0.14);
                --radius-lg: 28px;
                --radius-md: 16px;
                --radius-sm: 10px;
                --max-width: 1160px;
            }

            * {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
                color: var(--ink);
                background: radial-gradient(circle at top, #f7f7f7 0%, #efefef 45%, #e6e6e6 100%);
                min-height: 100vh;
            }

            header {
                padding: 48px 24px 20px;
            }

            .wrap {
                max-width: var(--max-width);
                margin: 0 auto;
            }

            .hero {
                display: grid;
                gap: 18px;
            }

            h1 {
                font-family: "Space Grotesk", "Segoe UI", sans-serif;
                font-size: clamp(2rem, 3.5vw, 3.6rem);
                margin: 0;
                letter-spacing: -0.02em;
            }

            .hero p {
                margin: 0;
                font-size: 1.05rem;
                color: var(--muted);
                max-width: 640px;
                line-height: 1.6;
            }

            .pill-row {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }

            .pill {
                background: var(--accent-soft);
                color: var(--accent-dark);
                padding: 8px 14px;
                border-radius: 999px;
                font-size: 0.9rem;
                font-weight: 600;
            }

            main {
                padding: 0 24px 60px;
            }

            .panel {
                background: var(--surface);
                border-radius: var(--radius-lg);
                padding: 26px;
                box-shadow: var(--shadow);
                border: 1px solid rgba(0, 0, 0, 0.04);
            }

            .layout {
                display: grid;
                gap: 22px;
            }

            @media (min-width: 900px) {
                .layout {
                    grid-template-columns: 1.2fr 0.8fr;
                    align-items: start;
                }
            }

            .dropzone {
                background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
                border: 2px dashed var(--line);
                border-radius: var(--radius-md);
                padding: 32px;
                text-align: center;
                transition:
                    border-color 0.2s ease,
                    transform 0.2s ease,
                    box-shadow 0.2s ease;
                position: relative;
            }

            .dropzone.active {
                border-color: var(--accent);
                box-shadow: 0 16px 32px rgba(0, 0, 0, 0.16);
                transform: translateY(-2px);
            }

            .dropzone h2 {
                font-family: "Space Grotesk", sans-serif;
                margin: 0 0 10px;
                font-size: 1.6rem;
            }

            .dropzone p {
                margin: 0 0 18px;
                color: var(--muted);
                line-height: 1.5;
            }

            .actions {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 12px;
            }

            .setting .actions {
                justify-content: flex-start;
            }

            .actions.actions-inline {
                width: 100%;
            }

            button,
            .btn {
                border: none;
                border-radius: 999px;
                padding: 10px 18px;
                font-weight: 600;
                cursor: pointer;
                font-size: 0.95rem;
                transition:
                    transform 0.2s ease,
                    box-shadow 0.2s ease;
            }

            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .btn-primary {
                background: var(--accent);
                color: white;
                box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
            }

            .btn-primary:hover:not(:disabled) {
                transform: translateY(-2px);
            }

            .btn-ghost {
                background: #ededed;
                color: var(--ink);
            }

            .btn-outline {
                background: transparent;
                border: 1px solid var(--line);
            }

            .settings {
                display: grid;
                gap: 18px;
            }

            .setting {
                background: var(--surface-alt);
                border-radius: var(--radius-md);
                padding: 16px;
                border: 1px solid rgba(0, 0, 0, 0.04);
            }

            .setting label {
                display: block;
                font-weight: 600;
                margin-bottom: 8px;
            }

            .setting small {
                color: var(--muted);
                display: block;
                margin-top: 6px;
            }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      #paletteValue {
        display: inline-block;
        width: 4ch;
        text-align: right;
        font-variant-numeric: tabular-nums;
        flex: 0 0 4ch;
      }

      .setting-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 8px;
      }

      .setting-header .chip {
        padding: 6px 12px;
        font-size: 0.85rem;
      }


      .quality-grid {
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 8px;
      }

      .size-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 8px;
      }

      .basis-row {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-bottom: 10px;
      }

            .chip {
                border: 1px solid var(--line);
                background: #fff;
                border-radius: 999px;
                padding: 8px 0;
                font-weight: 600;
                font-size: 0.9rem;
                cursor: pointer;
                transition:
                    transform 0.15s ease,
                    box-shadow 0.15s ease,
                    border-color 0.15s ease;
            }

            .chip.active {
                border-color: var(--accent);
                box-shadow: 0 10px 18px rgba(0, 0, 0, 0.18);
                transform: translateY(-1px);
            }

            input[type="range"] {
                width: 100%;
            }

            input[type="range"]:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            select,
            input[type="number"] {
                width: 100%;
                padding: 10px 12px;
                border-radius: 12px;
                border: 1px solid var(--line);
                font-size: 0.95rem;
                background: white;
            }

            .status {
                margin-top: 16px;
                font-weight: 600;
                color: var(--accent-dark);
            }

            .results {
                margin-top: 24px;
                display: grid;
                gap: 12px;
            }

            .result-card {
                background: white;
                border-radius: var(--radius-sm);
                border: 1px solid var(--line);
                padding: 14px;
                display: grid;
                gap: 8px;
            }

            .result-top {
                display: flex;
                flex-wrap: wrap;
                justify-content: space-between;
                gap: 8px;
            }

            .result-top strong {
                font-size: 0.95rem;
            }

            .result-meta {
                color: var(--muted);
                font-size: 0.85rem;
            }

            .result-actions {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .note {
                margin-top: 16px;
                color: var(--muted);
                font-size: 0.9rem;
                line-height: 1.5;
            }

            .footer-note {
                margin: 32px auto 24px;
                text-align: center;
                color: var(--muted);
                font-size: 0.85rem;
                line-height: 1.6;
            }

            .hidden {
                display: none;
            }
        </style>
    </head>
    <body>
        <header>
            <div class="wrap hero">
                <h1>이미지 최적화</h1>
                <!-- <div class="pill-row">
                    <span class="pill">폴더 재귀 처리</span>
                    <span class="pill">PNG · JPG · WebP 출력</span>
                    <span class="pill">메타데이터 제거</span>
                </div> -->
            </div>
        </header>

        <main>
            <div class="wrap layout panel">
                <section>
                    <div class="dropzone" id="dropzone">
                        <h2>이미지를 여기에 놓으세요</h2>
                        <p>파일/폴더 드래그앤드롭, 또는 선택 버튼을 눌러 업로드합니다.</p>
                        <div class="actions">
                            <button class="btn btn-primary" id="pickFiles">파일 선택</button>
                            <button class="btn btn-ghost" id="pickFolder">폴더 선택</button>
                            <button class="btn btn-outline" id="clearList">비우기</button>
                        </div>
                        <input id="fileInput" type="file" accept="image/*" multiple class="hidden" />
                        <input id="folderInput" type="file" accept="image/*" multiple webkitdirectory class="hidden" />
                        <div class="status" id="status">대기 중…</div>
                    </div>

                    <div class="results" id="results"></div>
                    <div class="note">PNG는 무손실 포맷이라 컬러 통합 효과가 크지만, 압축률은 이미지 종류에 따라 달라집니다.</div>
                </section>

                <aside class="settings">
                    <div class="setting">
                        <label for="formatButtons">출력 포맷</label>
                        <div class="quality-grid" id="formatButtons" role="radiogroup" aria-label="출력 포맷 선택">
                            <button type="button" class="chip" data-format="image/jpeg">JPG</button>
                            <button type="button" class="chip" data-format="image/png">PNG</button>
                            <button type="button" class="chip" data-format="image/webp">WebP</button>
                        </div>
                        <small>원본과 다른 포맷으로 변환하면 용량 절감 폭이 큽니다.</small>
                    </div>

                    <div class="setting">
                        <label for="resizeButtons">사이즈 조절</label>
                        <div class="basis-row" id="resizeBasisButtons" role="radiogroup" aria-label="사이즈 기준 선택">
                            <button type="button" class="chip" data-basis="width">가로 기준</button>
                            <button type="button" class="chip" data-basis="height">세로 기준</button>
                        </div>
                        <div class="size-grid" id="resizeButtons" role="radiogroup" aria-label="사이즈 선택">
                            <button type="button" class="chip" data-size="none">선택없음</button>
                            <button type="button" class="chip" data-size="640">640px</button>
                            <button type="button" class="chip" data-size="960">960px</button>
                            <button type="button" class="chip" data-size="1000">1000px</button>
                            <button type="button" class="chip" data-size="1280">1280px</button>
                            <button type="button" class="chip" data-size="1440">1440px</button>
                            <button type="button" class="chip" data-size="1920">1920px</button>
                            <button type="button" class="chip" data-size="2560">2560px</button>
                        </div>
                        <small>선택한 기준(px)에 맞춰 비율을 유지하며 리사이즈됩니다.</small>
                    </div>

                    <div class="setting">
                        <div class="setting-header">
                            <label for="paletteSize">컬러 팔레트 수</label>
                            <button type="button" class="chip" id="keepOriginalColors" aria-pressed="false">원본유지</button>
                        </div>
                        <div class="slider-row">
                            <input id="paletteSize" type="range" min="8" max="256" value="256" />
                            <span id="paletteValue">256</span>
                        </div>
                        <small>낮을수록 용량이 줄지만 밴딩이 생길 수 있습니다. 256은 색 통합 없음.</small>
                    </div>

                    <div class="setting">
                        <label for="qualityButtons">출력 품질 (JPG/WebP)</label>
                        <div class="quality-grid" id="qualityButtons" role="radiogroup" aria-label="출력 품질 선택">
                            <button type="button" class="chip" data-quality="0.1">10%</button>
                            <button type="button" class="chip" data-quality="0.2">20%</button>
                            <button type="button" class="chip" data-quality="0.3">30%</button>
                            <button type="button" class="chip" data-quality="0.4">40%</button>
                            <button type="button" class="chip" data-quality="0.5">50%</button>
                            <button type="button" class="chip" data-quality="0.6">60%</button>
                            <button type="button" class="chip" data-quality="0.7">70%</button>
                            <button type="button" class="chip" data-quality="0.8">80%</button>
                            <button type="button" class="chip" data-quality="0.9">90%</button>
                            <button type="button" class="chip" data-quality="1">100%</button>
                        </div>
                        <small>PNG는 무시됩니다.</small>
                    </div>

                    <div class="setting">
                        <label for="ditherToggle">디더링 (밴딩 완화)</label>
                        <div class="slider-row">
                            <input id="ditherToggle" type="checkbox" checked />
                            <span>활성화</span>
                        </div>
                        <small>미세 노이즈로 밴딩을 줄입니다. PNG는 용량이 조금 늘 수 있습니다.</small>
                    </div>

                    <div class="setting">
                        <label>처리 시작</label>
                        <div class="actions actions-inline">
                            <button class="btn btn-primary" id="startOptimize">최적화 실행</button>
                            <button class="btn btn-ghost" id="downloadAll" disabled>개별 저장</button>
                            <button class="btn btn-outline" id="saveFolder" disabled>폴더로 저장</button>
                        </div>
                        <small>큰 이미지는 처리 시간이 다소 걸릴 수 있습니다.</small>
                    </div>
                </aside>
            </div>
        </main>

        <footer class="footer-note">
            <div>Created by CHK</div>
            <div>This project is open source under the MIT License.</div>
        </footer>

        <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.js" onerror="this.onerror=null;this.src='https://unpkg.com/upng-js@2.1.0/UPNG.js'"></script>
        <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
        <script>
            const dropzone = document.getElementById("dropzone");
            const fileInput = document.getElementById("fileInput");
            const folderInput = document.getElementById("folderInput");
            const pickFiles = document.getElementById("pickFiles");
            const pickFolder = document.getElementById("pickFolder");
            const clearList = document.getElementById("clearList");
            const resultsEl = document.getElementById("results");
            const statusEl = document.getElementById("status");
            const paletteSlider = document.getElementById("paletteSize");
            const paletteValue = document.getElementById("paletteValue");
            const keepOriginalColors = document.getElementById("keepOriginalColors");
            const qualityButtons = document.getElementById("qualityButtons");
            const formatButtons = document.getElementById("formatButtons");
            const resizeButtons = document.getElementById("resizeButtons");
            const resizeBasisButtons = document.getElementById("resizeBasisButtons");
            const startOptimize = document.getElementById("startOptimize");
            const downloadAll = document.getElementById("downloadAll");
            const saveFolder = document.getElementById("saveFolder");
            const ditherToggle = document.getElementById("ditherToggle");

            const state = {
                files: [],
                results: [],
            };

            const supportedExt = ["jpg", "jpeg", "png", "webp", "avif"];
            const storageKey = "imageOptimizationPrefs";
            const isUpngReady = () => typeof window.UPNG !== "undefined" && typeof UPNG.encode === "function";
            const updatePaletteLabel = () => {
                paletteValue.textContent = paletteSlider.value;
            };

            const updateKeepOriginalColors = (value) => {
                keepOriginalColors.classList.toggle("active", value);
                keepOriginalColors.setAttribute("aria-pressed", value ? "true" : "false");
                paletteSlider.disabled = value;
            };

            const updateQualityButtons = (value) => {
                const buttons = Array.from(qualityButtons.querySelectorAll(".chip"));
                buttons.forEach((button) => {
                    const isActive = Number(button.dataset.quality) === value;
                    button.classList.toggle("active", isActive);
                    button.setAttribute("aria-checked", isActive ? "true" : "false");
                });
            };

            const updateFormatButtons = (value) => {
                const buttons = Array.from(formatButtons.querySelectorAll(".chip"));
                let matched = false;
                buttons.forEach((button) => {
                    const isActive = button.dataset.format === value;
                    if (isActive) matched = true;
                    button.classList.toggle("active", isActive);
                    button.setAttribute("aria-checked", isActive ? "true" : "false");
                });
                if (!matched) {
                    const fallback = buttons.find((button) => button.dataset.format === "image/jpeg");
                    if (fallback) {
                        fallback.classList.add("active");
                        fallback.setAttribute("aria-checked", "true");
                    }
                }
            };

            const updateResizeButtons = (value) => {
                const buttons = Array.from(resizeButtons.querySelectorAll(".chip"));
                let matched = false;
                buttons.forEach((button) => {
                    const sizeValue = button.dataset.size === "none" ? null : Number(button.dataset.size);
                    const isActive = value === null ? sizeValue === null : sizeValue === value;
                    if (isActive) matched = true;
                    button.classList.toggle("active", isActive);
                    button.setAttribute("aria-checked", isActive ? "true" : "false");
                });
                if (!matched) {
                    const fallback = buttons.find((button) => button.dataset.size === "none");
                    if (fallback) {
                        fallback.classList.add("active");
                        fallback.setAttribute("aria-checked", "true");
                    }
                }
            };

            const updateResizeBasisButtons = (value) => {
                const buttons = Array.from(resizeBasisButtons.querySelectorAll(".chip"));
                let matched = false;
                buttons.forEach((button) => {
                    const isActive = button.dataset.basis === value;
                    if (isActive) matched = true;
                    button.classList.toggle("active", isActive);
                    button.setAttribute("aria-checked", isActive ? "true" : "false");
                });
                if (!matched) {
                    const fallback = buttons.find((button) => button.dataset.basis === "width");
                    if (fallback) {
                        fallback.classList.add("active");
                        fallback.setAttribute("aria-checked", "true");
                    }
                }
            };

            const getSelectedQuality = () => {
                const active = qualityButtons.querySelector(".chip.active");
                const value = Number(active?.dataset?.quality);
                return Number.isFinite(value) ? value : 1;
            };

            const getSelectedFormat = () => {
                const active = formatButtons.querySelector(".chip.active");
                return active?.dataset?.format || "image/jpeg";
            };

            const getKeepOriginalColors = () => keepOriginalColors.classList.contains("active");

            const getSelectedResizeSize = () => {
                const active = resizeButtons.querySelector(".chip.active");
                const raw = active?.dataset?.size;
                if (raw === "none") return null;
                const value = Number(raw);
                return Number.isFinite(value) ? value : null;
            };

            const getSelectedResizeBasis = () => {
                const active = resizeBasisButtons.querySelector(".chip.active");
                return active?.dataset?.basis === "height" ? "height" : "width";
            };

            const savePrefs = () => {
                try {
                    const prefs = {
                        format: getSelectedFormat(),
                        palette: Number(paletteSlider.value),
                        quality: getSelectedQuality(),
                        resizeSize: getSelectedResizeSize(),
                        resizeBasis: getSelectedResizeBasis(),
                        keepOriginalColors: getKeepOriginalColors(),
                    };
                    localStorage.setItem(storageKey, JSON.stringify(prefs));
                } catch {
                    // Ignore storage errors (private mode, quota, etc.)
                }
            };

            const applyPrefs = () => {
                try {
                    const raw = localStorage.getItem(storageKey);
                    if (!raw) return false;
                    const prefs = JSON.parse(raw);
                    if (prefs?.format) {
                        updateFormatButtons(prefs.format);
                    } else {
                        updateFormatButtons("image/jpeg");
                    }
                    if (Number.isFinite(prefs?.palette)) {
                        const value = Math.min(256, Math.max(8, Number(prefs.palette)));
                        paletteSlider.value = String(value);
                    }
                    const qualityValue = Number.isFinite(prefs?.quality) ? Number(prefs.quality) : 0.8;
                    updateQualityButtons(Math.min(1, Math.max(0.1, qualityValue)));

                    const resizeValue = Number.isFinite(prefs?.resizeSize) ? Number(prefs.resizeSize) : null;
                    updateResizeButtons(resizeValue);

                    const basisValue = prefs?.resizeBasis === "height" ? "height" : "width";
                    updateResizeBasisButtons(basisValue);

                    updateKeepOriginalColors(Boolean(prefs?.keepOriginalColors));
                    return true;
                } catch {
                    localStorage.removeItem(storageKey);
                    return false;
                }
            };

            const hasPrefs = applyPrefs();
            updatePaletteLabel();
            if (!hasPrefs) {
                updateFormatButtons("image/jpeg");
            }
            if (!hasPrefs) {
                updateQualityButtons(0.8);
            }
            if (!hasPrefs) {
                updateResizeButtons(null);
                updateResizeBasisButtons("width");
            }
            if (!hasPrefs) {
                updateKeepOriginalColors(false);
            }

            function setStatus(text, tone = "default") {
                statusEl.textContent = text;
                statusEl.style.color = tone === "success" ? "var(--success)" : "var(--accent-dark)";
            }

            function formatBytes(bytes) {
                if (!Number.isFinite(bytes)) return "-";
                const units = ["B", "KB", "MB", "GB"];
                let idx = 0;
                let value = bytes;
                while (value >= 1024 && idx < units.length - 1) {
                    value /= 1024;
                    idx += 1;
                }
                return `${value.toFixed(value < 10 ? 2 : 1)} ${units[idx]}`;
            }

            function sanitizeFiles(files) {
                return files.filter((item) => {
                    const ext = item.name.split(".").pop()?.toLowerCase() || "";
                    return item.file.type.startsWith("image/") || supportedExt.includes(ext);
                });
            }

            function updateCounters() {
                setStatus(state.files.length ? `${state.files.length}개 파일 준비됨` : "대기 중…");
            }

            function resetResults() {
                state.results = [];
                resultsEl.innerHTML = "";
                downloadAll.disabled = true;
                saveFolder.disabled = true;
            }

            pickFiles.addEventListener("click", () => fileInput.click());
            pickFolder.addEventListener("click", () => folderInput.click());
            clearList.addEventListener("click", () => {
                state.files = [];
                resetResults();
                updateCounters();
            });

            paletteSlider.addEventListener("input", () => {
                updatePaletteLabel();
                savePrefs();
            });

            keepOriginalColors.addEventListener("click", () => {
                const next = !getKeepOriginalColors();
                updateKeepOriginalColors(next);
                savePrefs();
            });

            qualityButtons.addEventListener("click", (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const value = Number(target.dataset.quality);
                if (!Number.isFinite(value)) return;
                updateQualityButtons(value);
                savePrefs();
            });

            formatButtons.addEventListener("click", (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const value = target.dataset.format;
                if (!value) return;
                updateFormatButtons(value);
                savePrefs();
            });

            resizeButtons.addEventListener("click", (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const raw = target.dataset.size;
                const value = raw === "none" ? null : Number(raw);
                if (raw !== "none" && !Number.isFinite(value)) return;
                updateResizeButtons(value);
                savePrefs();
            });

            resizeBasisButtons.addEventListener("click", (event) => {
                const target = event.target;
                if (!(target instanceof HTMLElement)) return;
                const value = target.dataset.basis;
                if (!value) return;
                updateResizeBasisButtons(value);
                savePrefs();
            });

            fileInput.addEventListener("change", () => {
                const files = Array.from(fileInput.files || []).map((file) => ({
                    file,
                    name: file.name,
                    relPath: file.name,
                }));
                state.files = sanitizeFiles(files);
                resetResults();
                updateCounters();
            });

            folderInput.addEventListener("change", () => {
                const files = Array.from(folderInput.files || []).map((file) => ({
                    file,
                    name: file.name,
                    relPath: file.webkitRelativePath || file.name,
                }));
                state.files = sanitizeFiles(files);
                resetResults();
                updateCounters();
            });

            ["dragenter", "dragover"].forEach((eventName) => {
                dropzone.addEventListener(eventName, (event) => {
                    event.preventDefault();
                    dropzone.classList.add("active");
                });
            });

            ["dragleave", "drop"].forEach((eventName) => {
                dropzone.addEventListener(eventName, (event) => {
                    event.preventDefault();
                    dropzone.classList.remove("active");
                });
            });

            dropzone.addEventListener("drop", async (event) => {
                const collected = await readDropItems(event.dataTransfer);
                state.files = sanitizeFiles(collected);
                resetResults();
                updateCounters();
            });

            document.addEventListener("dragover", (event) => {
                event.preventDefault();
            });

            document.addEventListener("drop", async (event) => {
                event.preventDefault();
                if (dropzone.contains(event.target)) return;
                const collected = await readDropItems(event.dataTransfer);
                if (!collected.length) return;
                state.files = sanitizeFiles(collected);
                resetResults();
                updateCounters();
                dropzone.classList.remove("active");
            });

            async function readDropItems(dataTransfer) {
                if (!dataTransfer) return [];
                const items = dataTransfer.items;
                const files = dataTransfer.files;

                const entries = [];
                if (items && items.length) {
                    for (const item of items) {
                        if (item.webkitGetAsEntry) {
                            const entry = item.webkitGetAsEntry();
                            if (entry) entries.push(entry);
                        } else if (item.getAsFile) {
                            const file = item.getAsFile();
                            if (file) {
                                entries.push({
                                    isFile: true,
                                    isDirectory: false,
                                    file: (cb) => cb(file),
                                    fullPath: file.name,
                                });
                            }
                        }
                    }
                } else if (files && files.length) {
                    for (const file of files) {
                        entries.push({
                            isFile: true,
                            isDirectory: false,
                            file: (cb) => cb(file),
                            fullPath: file.name,
                        });
                    }
                }

                const collected = [];
                for (const entry of entries) {
                    const sub = await collectEntries(entry);
                    collected.push(...sub);
                }
                return collected;
            }

            async function collectEntries(entry) {
                if (entry.isFile) {
                    const file = await new Promise((resolve) => entry.file(resolve));
                    return [
                        {
                            file,
                            name: file.name,
                            relPath: entry.fullPath?.replace(/^\//, "") || file.name,
                        },
                    ];
                }
                if (!entry.isDirectory) return [];

                const reader = entry.createReader();
                const results = [];
                const readBatch = () => new Promise((resolve) => reader.readEntries(resolve));

                let batch = await readBatch();
                while (batch.length) {
                    for (const item of batch) {
                        const sub = await collectEntries(item);
                        results.push(...sub);
                    }
                    batch = await readBatch();
                }
                return results;
            }

            startOptimize.addEventListener("click", async () => {
                if (!state.files.length) {
                    setStatus("먼저 파일이나 폴더를 선택하세요.");
                    return;
                }
                resetResults();
                setStatus("최적화 진행 중...");
                startOptimize.disabled = true;
                pickFiles.disabled = true;
                pickFolder.disabled = true;

                const paletteSize = Number(paletteSlider.value);
                const quality = getSelectedQuality();
                const targetType = getSelectedFormat();
                const resizeSize = getSelectedResizeSize();
                const resizeBasis = getSelectedResizeBasis();
                const keepColors = getKeepOriginalColors();
                const dither = ditherToggle.checked;
                if (targetType === "image/png" && !isUpngReady()) {
                    setStatus("PNG 최적화용 UPNG.js를 불러오지 못했습니다. 네트워크/차단 설정을 확인하세요.");
                    startOptimize.disabled = false;
                    pickFiles.disabled = false;
                    pickFolder.disabled = false;
                    return;
                }

                for (let i = 0; i < state.files.length; i += 1) {
                    const item = state.files[i];
                    try {
                        const result = await optimizeFile(item, {
                            paletteSize,
                            quality,
                            targetType,
                            resizeSize,
                            resizeBasis,
                            keepColors,
                            dither,
                        });
                        state.results.push(result);
                        renderResult(result);
                        setStatus(`진행 ${i + 1}/${state.files.length}`);
                    } catch (error) {
                        renderError(item, error);
                    }
                }

                setStatus("완료!", "success");
                startOptimize.disabled = false;
                pickFiles.disabled = false;
                pickFolder.disabled = false;
                downloadAll.disabled = state.results.length === 0;
                saveFolder.disabled = state.results.length === 0 || !state.results.some((result) => result.outputName.includes("/"));
            });

            downloadAll.addEventListener("click", () => {
                state.results.forEach((result) => {
                    triggerDownload(result.blobUrl, result.outputName);
                });
            });

            saveFolder.addEventListener("click", () => {
                saveAllToFolder(state.results);
            });

            function renderResult(result) {
                const card = document.createElement("div");
                card.className = "result-card";
                card.innerHTML = `
          <div class="result-top">
            <strong>${result.outputName}</strong>
            <span class="result-meta">${result.dimensions}</span>
          </div>
          <div class="result-meta">
            원본 ${formatBytes(result.originalSize)} → 결과 ${formatBytes(result.outputSize)} (${result.savings}% 절감)
          </div>
          <div class="result-actions">
            <button class="btn btn-primary">다운로드</button>
            <button class="btn btn-outline">미리보기</button>
          </div>
        `;
                const [downloadBtn, previewBtn] = card.querySelectorAll("button");
                downloadBtn.addEventListener("click", () => triggerDownload(result.blobUrl, result.outputName));
                previewBtn.addEventListener("click", () => window.open(result.blobUrl, "_blank"));
                resultsEl.appendChild(card);
            }

            function renderError(item, error) {
                const card = document.createElement("div");
                card.className = "result-card";
                card.innerHTML = `
          <div class="result-top">
            <strong>${item.relPath}</strong>
          </div>
          <div class="result-meta">처리 실패: ${error.message}</div>
        `;
                resultsEl.appendChild(card);
            }

            function triggerDownload(url, filename) {
                const link = document.createElement("a");
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                link.remove();
            }

            function getTopFolderName(path) {
                const parts = path.split("/");
                return parts.length > 1 ? parts[0] : null;
            }

            function getBaseName(path) {
                const name = path.split("/").pop() || "image";
                return name.replace(/\.[^/.]+$/, "") || "image";
            }

            function groupResultsByFolder(results) {
                const groups = new Map();
                results.forEach((result) => {
                    const folder = getTopFolderName(result.outputName) || "__root__";
                    if (!groups.has(folder)) groups.set(folder, []);
                    groups.get(folder).push(result);
                });
                return groups;
            }

            async function saveAllToFolder(results) {
                if (!results.length) return;
                if (typeof JSZip === "undefined") {
                    setStatus("ZIP 라이브러리를 불러오지 못했습니다. 개별 다운로드로 전환합니다.");
                    results.forEach((result) => {
                        triggerDownload(result.blobUrl, result.outputName);
                    });
                    return;
                }

                const groups = groupResultsByFolder(results);
                try {
                    let idx = 0;
                    const total = groups.size;
                    for (const [folder, items] of groups.entries()) {
                        idx += 1;
                        setStatus(`ZIP 생성 중... (${idx}/${total})`);
                        const zip = new JSZip();
                        items.forEach((result) => {
                            zip.file(result.outputName, result.blob);
                        });
                        const blob = await zip.generateAsync({
                            type: "blob",
                            compression: "DEFLATE",
                            compressionOptions: { level: 6 },
                        });
                        const zipUrl = URL.createObjectURL(blob);
                        const zipName =
                            folder === "__root__"
                                ? items.length === 1
                                    ? getBaseName(items[0].outputName)
                                    : "optimized-images"
                                : folder;
                        triggerDownload(zipUrl, `${zipName}.zip`);
                        setTimeout(() => URL.revokeObjectURL(zipUrl), 10000);
                    }
                    setStatus("ZIP 다운로드 준비 완료!", "success");
                } catch (error) {
                    setStatus("ZIP 생성 실패. 개별 다운로드로 전환합니다.");
                    results.forEach((result) => {
                        triggerDownload(result.blobUrl, result.outputName);
                    });
                }
            }

            async function optimizeFile(item, options) {
                const { paletteSize, quality, targetType, resizeSize, resizeBasis, keepColors, dither } = options;
                const file = item.file;
                const bitmap = await loadBitmap(file);
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d", { willReadFrequently: true });
                let targetWidth = bitmap.width;
                let targetHeight = bitmap.height;
                if (resizeSize) {
                    const basisValue = resizeBasis === "height" ? bitmap.height : bitmap.width;
                    const scale = basisValue > 0 ? resizeSize / basisValue : 1;
                    targetWidth = Math.max(1, Math.round(bitmap.width * scale));
                    targetHeight = Math.max(1, Math.round(bitmap.height * scale));
                }
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                ctx.drawImage(bitmap, 0, 0, targetWidth, targetHeight);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                if (!keepColors && paletteSize < 256) {
                    const palette = buildPalette(imageData.data, paletteSize);
                    applyPalette(imageData.data, palette, canvas.width, canvas.height, dither);
                    ctx.putImageData(imageData, 0, 0);
                }

                let blobData;
                if (targetType === "image/png" && window.UPNG && typeof UPNG.encode === "function") {
                    try {
                        const rgba = new Uint8Array(imageData.data);
                        const colorCount = !keepColors && paletteSize < 256 ? paletteSize : 0;
                        const pngBuffer = UPNG.encode([rgba.buffer], canvas.width, canvas.height, colorCount);
                        blobData = { blob: new Blob([pngBuffer], { type: "image/png" }), typeUsed: "image/png" };
                    } catch {
                        blobData = await canvasToBlob(canvas, targetType, quality);
                    }
                } else {
                    blobData = await canvasToBlob(canvas, targetType, quality);
                }
                const { blob, typeUsed } = blobData;
                const outputName = renameFile(item.relPath, typeUsed);
                const outputSize = blob.size;
                const originalSize = file.size;
                const savings = Math.max(0, Math.round(((originalSize - outputSize) / originalSize) * 100));

                return {
                    blob,
                    blobUrl: URL.createObjectURL(blob),
                    outputName,
                    outputSize,
                    originalSize,
                    savings,
                    dimensions: `${canvas.width}×${canvas.height}`,
                };
            }

            function renameFile(path, typeUsed) {
                const ext = typeUsed.split("/")[1] || "png";
                const cleanExt = ext === "jpeg" ? "jpg" : ext;
                const parts = path.split("/");
                const name = parts.pop() || "image";
                const base = name.replace(/\.[^/.]+$/, "");
                parts.push(`${base}.${cleanExt}`);
                return parts.join("/");
            }

            async function loadBitmap(file) {
                if ("createImageBitmap" in window) {
                    return createImageBitmap(file);
                }
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            function buildPalette(data, size) {
                const total = data.length / 4;
                const targetSamples = Math.min(20000, total);
                const stride = Math.max(1, Math.floor(Math.sqrt(total / targetSamples)));
                const samples = [];

                for (let i = 0; i < data.length; i += 4 * stride) {
                    const alpha = data[i + 3];
                    if (alpha < 12) continue;
                    samples.push([data[i], data[i + 1], data[i + 2]]);
                }

                if (samples.length === 0) return [[0, 0, 0]];
                const palette = [];
                for (let i = 0; i < size; i += 1) {
                    const pick = samples[Math.floor(Math.random() * samples.length)];
                    palette.push([...pick]);
                }

                for (let iter = 0; iter < 8; iter += 1) {
                    const sums = Array.from({ length: size }, () => ({
                        r: 0,
                        g: 0,
                        b: 0,
                        count: 0,
                    }));
                    for (const sample of samples) {
                        const idx = nearestColor(sample, palette);
                        const bucket = sums[idx];
                        bucket.r += sample[0];
                        bucket.g += sample[1];
                        bucket.b += sample[2];
                        bucket.count += 1;
                    }
                    for (let i = 0; i < palette.length; i += 1) {
                        if (sums[i].count > 0) {
                            palette[i][0] = Math.round(sums[i].r / sums[i].count);
                            palette[i][1] = Math.round(sums[i].g / sums[i].count);
                            palette[i][2] = Math.round(sums[i].b / sums[i].count);
                        } else {
                            const pick = samples[Math.floor(Math.random() * samples.length)];
                            palette[i] = [...pick];
                        }
                    }
                }

                return palette;
            }

            function nearestColor([r, g, b], palette) {
                let bestIdx = 0;
                let bestDist = Infinity;
                for (let i = 0; i < palette.length; i += 1) {
                    const pr = palette[i][0];
                    const pg = palette[i][1];
                    const pb = palette[i][2];
                    const dr = r - pr;
                    const dg = g - pg;
                    const db = b - pb;
                    const dist = dr * dr * 0.3 + dg * dg * 0.59 + db * db * 0.11;
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestIdx = i;
                    }
                }
                return bestIdx;
            }

            function applyPalette(data, palette, width, height, dither) {
                if (!dither) {
                    const cache = new Map();
                    for (let i = 0; i < data.length; i += 4) {
                        const alpha = data[i + 3];
                        if (alpha === 0) continue;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const key = ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3);
                        let mapped = cache.get(key);
                        if (!mapped) {
                            const idx = nearestColor([r, g, b], palette);
                            mapped = palette[idx];
                            cache.set(key, mapped);
                        }
                        data[i] = mapped[0];
                        data[i + 1] = mapped[1];
                        data[i + 2] = mapped[2];
                    }
                    return;
                }

                const clamp = (value) => Math.max(0, Math.min(255, value));
                for (let y = 0; y < height; y += 1) {
                    for (let x = 0; x < width; x += 1) {
                        const idx = (y * width + x) * 4;
                        const alpha = data[idx + 3];
                        if (alpha === 0) continue;

                        const oldR = data[idx];
                        const oldG = data[idx + 1];
                        const oldB = data[idx + 2];
                        const paletteIndex = nearestColor([oldR, oldG, oldB], palette);
                        const mapped = palette[paletteIndex];

                        data[idx] = mapped[0];
                        data[idx + 1] = mapped[1];
                        data[idx + 2] = mapped[2];

                        const errR = oldR - mapped[0];
                        const errG = oldG - mapped[1];
                        const errB = oldB - mapped[2];

                        distributeError(x + 1, y, 7 / 16, errR, errG, errB);
                        distributeError(x - 1, y + 1, 3 / 16, errR, errG, errB);
                        distributeError(x, y + 1, 5 / 16, errR, errG, errB);
                        distributeError(x + 1, y + 1, 1 / 16, errR, errG, errB);
                    }
                }

                function distributeError(nx, ny, factor, errR, errG, errB) {
                    if (nx < 0 || ny < 0 || nx >= width || ny >= height) return;
                    const nIdx = (ny * width + nx) * 4;
                    if (data[nIdx + 3] === 0) return;
                    data[nIdx] = clamp(data[nIdx] + errR * factor);
                    data[nIdx + 1] = clamp(data[nIdx + 1] + errG * factor);
                    data[nIdx + 2] = clamp(data[nIdx + 2] + errB * factor);
                }
            }

            async function canvasToBlob(canvas, type, quality) {
                const tryBlob = (mime) => new Promise((resolve) => canvas.toBlob(resolve, mime, quality));

                let blob = await tryBlob(type);
                let typeUsed = type;
                if (!blob) {
                    const fallback = type === "image/avif" ? "image/webp" : "image/png";
                    blob = await tryBlob(fallback);
                    typeUsed = fallback;
                }
                return { blob, typeUsed };
            }
        </script>
    </body>
</html>
