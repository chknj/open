<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>이미지 다운로더</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%98%84%3C/text%3E%3C/svg%3E">
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;700&family=Noto+Sans+KR:wght@400;500;700&display=swap");

    :root {
      --bg: #f3f6f3;
      --panel: #ffffff;
      --line: #c9d4cb;
      --text: #0f172a;
      --muted: #52606f;
      --brand: #0f766e;
      --brand-soft: #d9f3ef;
      --alert: #b45309;
      --danger: #b91c1c;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Noto Sans KR", system-ui, sans-serif;
      color: var(--text);
      background:
        radial-gradient(circle at 5% 0%, #e4f8f3 0%, transparent 36%),
        radial-gradient(circle at 95% 0%, #fff1de 0%, transparent 34%),
        var(--bg);
      min-height: 100vh;
    }

    .app {
      width: min(1100px, 100%);
      margin: 0 auto;
      padding: 1.2rem;
    }

    .hero {
      border: 1px solid var(--line);
      background: var(--panel);
      border-radius: 18px;
      padding: 1rem 1rem 1.1rem;
      box-shadow: 0 10px 28px rgba(15, 23, 42, 0.05);
    }

    .title {
      margin: 0;
      font: 700 1.26rem/1.2 "Space Grotesk", "Noto Sans KR", sans-serif;
      letter-spacing: 0.02em;
    }

    .desc {
      margin: 0.52rem 0 0;
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.45;
    }

    .toolbar {
      margin-top: 1rem;
      display: grid;
      gap: 0.55rem;
      grid-template-columns: 1fr;
    }

    .url-row {
      display: grid;
      gap: 0.55rem;
      grid-template-columns: 1fr;
    }

    .url-input,
    .proxy-select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      font: 500 0.95rem/1.4 "Noto Sans KR", system-ui, sans-serif;
      color: var(--text);
      padding: 0.72rem 0.8rem;
    }

    .url-input:focus,
    .proxy-select:focus {
      outline: 2px solid rgba(15, 118, 110, 0.25);
      outline-offset: 1px;
      border-color: #8dd4cb;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.55rem;
      align-items: center;
    }

    button {
      border: 1px solid transparent;
      border-radius: 10px;
      font: 700 0.87rem/1 "Space Grotesk", "Noto Sans KR", sans-serif;
      letter-spacing: 0.01em;
      padding: 0.7rem 0.92rem;
      cursor: pointer;
      transition: transform 0.16s ease, box-shadow 0.16s ease, background-color 0.16s ease;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-primary {
      background: var(--brand);
      color: #fff;
      box-shadow: 0 8px 22px rgba(15, 118, 110, 0.23);
    }

    .btn-soft {
      background: var(--brand-soft);
      border-color: #8dd4cb;
      color: #134e4a;
    }

    .btn-light {
      background: #fff;
      border-color: var(--line);
      color: #334155;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
    }

    .agree-row {
      display: flex;
      align-items: start;
      gap: 0.5rem;
      margin-top: 0.2rem;
      font-size: 0.84rem;
      color: #374151;
    }

    .agree-row input { margin-top: 0.22rem; }

    .status {
      margin-top: 0.75rem;
      border-radius: 10px;
      padding: 0.62rem 0.72rem;
      font-size: 0.84rem;
      border: 1px solid #d7e4de;
      background: #f6fbf9;
      color: #174b45;
      min-height: 2.2rem;
      display: flex;
      align-items: center;
    }

    .status.warn {
      border-color: #f2d9b2;
      background: #fff7eb;
      color: #8a5604;
    }

    .status.error {
      border-color: #f1c7c7;
      background: #fff1f2;
      color: #991b1b;
    }

    .results {
      margin-top: 1rem;
      border: 1px solid var(--line);
      border-radius: 16px;
      background: var(--panel);
      padding: 0.9rem;
      min-height: 280px;
      box-shadow: 0 8px 22px rgba(15, 23, 42, 0.05);
    }

    .results-head {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.7rem;
    }

    .results-title {
      margin: 0;
      font: 700 1rem/1.25 "Space Grotesk", "Noto Sans KR", sans-serif;
    }

    .meta {
      font-size: 0.83rem;
      color: var(--muted);
    }

    .grid {
      display: grid;
      gap: 0.7rem;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    }

    .card {
      border: 1px solid #d4e0d7;
      border-radius: 12px;
      overflow: hidden;
      background: #fff;
      display: grid;
      grid-template-rows: 120px auto;
    }

    .thumb-wrap {
      background: #edf5f0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .thumb-wrap img {
      max-width: 100%;
      max-height: 100%;
      display: block;
      object-fit: contain;
    }

    .thumb-fallback {
      color: #5b6672;
      font-size: 0.79rem;
      text-align: center;
      padding: 0 0.5rem;
      line-height: 1.35;
    }

    .card-body {
      padding: 0.55rem 0.58rem 0.62rem;
      display: grid;
      gap: 0.32rem;
    }

    .check-row {
      display: flex;
      gap: 0.42rem;
      align-items: center;
      font-size: 0.82rem;
      color: #111827;
    }

    .path {
      font-size: 0.74rem;
      color: #64748b;
      word-break: break-all;
      line-height: 1.34;
      min-height: 2em;
    }

    .source-tag {
      font-size: 0.72rem;
      color: #0f766e;
      background: #e8f8f5;
      border-radius: 999px;
      width: fit-content;
      padding: 0.2rem 0.45rem;
    }

    .empty {
      border: 1px dashed #c9d4cb;
      border-radius: 12px;
      min-height: 190px;
      display: grid;
      place-items: center;
      text-align: center;
      color: #5d6b7a;
      font-size: 0.86rem;
      padding: 1.2rem;
      line-height: 1.45;
    }

    .legal {
      margin-top: 0.8rem;
      padding: 0.72rem;
      border: 1px solid #f3d7a8;
      background: #fff8ed;
      border-radius: 10px;
      font-size: 0.78rem;
      color: #8a5604;
      line-height: 1.45;
    }

    .foot {
      margin-top: 0.75rem;
      font-size: 0.76rem;
      color: #6b7280;
      line-height: 1.4;
    }

    .link {
      color: #0f766e;
      text-decoration: none;
      font-weight: 600;
    }

    .footer-note {
      margin-top: 0.9rem;
      text-align: center;
      color: var(--muted);
      font-size: 0.78rem;
      line-height: 1.5;
    }

    @media (min-width: 880px) {
      .toolbar {
        grid-template-columns: 1fr auto;
        align-items: end;
      }
      .url-row {
        grid-template-columns: 1fr 200px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="hero">
      <h1 class="title">Page Image Downloader</h1>
      <p class="desc">
        페이지 URL을 입력하면 이미지 링크를 수집해 선택 다운로드할 수 있습니다.
        공개 페이지에서, 본인이 권한을 가진 콘텐츠에만 사용하세요.
      </p>

      <div class="toolbar">
        <div class="url-row">
          <input id="urlInput" class="url-input" type="url" placeholder="https://example.com" autocomplete="off">
          <select id="proxySelect" class="proxy-select" aria-label="수집 방식">
            <option value="auto">수집 방식: 자동 (권장)</option>
            <option value="direct">수집 방식: 직접 요청만</option>
            <option value="allorigins">수집 방식: AllOrigins</option>
            <option value="corsproxy">수집 방식: corsproxy.io</option>
          </select>
        </div>

        <div class="btn-row">
          <button id="scanBtn" class="btn-primary" type="button">이미지 찾기</button>
          <button id="selectAllBtn" class="btn-light" type="button" disabled>전체 선택</button>
          <button id="clearSelectBtn" class="btn-light" type="button" disabled>선택 해제</button>
          <button id="downloadSelectedBtn" class="btn-soft" type="button" disabled>선택 다운로드</button>
          <button id="downloadZipBtn" class="btn-soft" type="button" disabled>ZIP 저장</button>
        </div>
      </div>

      <label class="agree-row">
        <input id="agreeInput" type="checkbox">
        <span>저작권/소유권/이용약관을 준수하며, 공개되어 있고 다운로드 권한이 있는 페이지에서만 사용합니다.</span>
      </label>

      <div id="status" class="status">준비됨</div>

      <div class="legal">
        이 도구는 로그인 우회, 접근제어 우회, DRM 우회 기능을 제공하지 않습니다.
        수집 실패 시 해당 사이트의 CORS, robots 정책, 서버 차단 또는 프록시 제한 때문일 수 있습니다.
      </div>
    </section>

    <section class="results">
      <div class="results-head">
        <h2 class="results-title">수집된 이미지</h2>
        <div id="meta" class="meta">0개</div>
      </div>
      <div id="grid" class="grid"></div>
      <div id="emptyState" class="empty">
        URL 입력 후 <b>이미지 찾기</b>를 누르세요.<br>
        (권한 확인 체크가 필요합니다.)
      </div>
      <p class="foot">
        오픈소스/무료 서비스 사용:
        <a class="link" href="https://stuk.github.io/jszip/" target="_blank" rel="noopener">JSZip</a>,
        <a class="link" href="https://allorigins.win/" target="_blank" rel="noopener">AllOrigins</a>,
        <a class="link" href="https://corsproxy.io/" target="_blank" rel="noopener">corsproxy.io</a>
      </p>
    </section>
    <footer class="footer-note">
      <div>Created by CHK</div>
      <div>This project is open source under the MIT License.</div>
    </footer>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const urlInput = document.getElementById("urlInput");
    const proxySelect = document.getElementById("proxySelect");
    const agreeInput = document.getElementById("agreeInput");
    const scanBtn = document.getElementById("scanBtn");
    const selectAllBtn = document.getElementById("selectAllBtn");
    const clearSelectBtn = document.getElementById("clearSelectBtn");
    const downloadSelectedBtn = document.getElementById("downloadSelectedBtn");
    const downloadZipBtn = document.getElementById("downloadZipBtn");
    const statusEl = document.getElementById("status");
    const metaEl = document.getElementById("meta");
    const gridEl = document.getElementById("grid");
    const emptyStateEl = document.getElementById("emptyState");

    const routeBuilders = {
      direct: (url) => url,
      allorigins: (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      corsproxy: (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`
    };

    let imageItems = [];
    let busy = false;
    let idCounter = 0;

    function setStatus(message, type) {
      statusEl.textContent = message;
      statusEl.classList.remove("warn", "error");
      if (type === "warn") statusEl.classList.add("warn");
      if (type === "error") statusEl.classList.add("error");
    }

    function nextId() {
      idCounter += 1;
      if (window.crypto && typeof window.crypto.randomUUID === "function") {
        return window.crypto.randomUUID();
      }
      return `img-${Date.now()}-${idCounter}`;
    }

    function setBusy(nextBusy) {
      busy = nextBusy;
      const hasItems = imageItems.length > 0;
      scanBtn.disabled = nextBusy;
      selectAllBtn.disabled = nextBusy || !hasItems;
      clearSelectBtn.disabled = nextBusy || !hasItems;
      downloadSelectedBtn.disabled = nextBusy || !hasItems;
      downloadZipBtn.disabled = nextBusy || !hasItems;
      urlInput.disabled = nextBusy;
      proxySelect.disabled = nextBusy;
      agreeInput.disabled = nextBusy;
    }

    function normalizeHttpUrl(value) {
      const trimmed = value.trim();
      if (!trimmed) return null;
      const withProtocol = /^https?:\/\//i.test(trimmed) ? trimmed : `https://${trimmed}`;
      try {
        const parsed = new URL(withProtocol);
        if (!/^https?:$/i.test(parsed.protocol)) return null;
        return parsed.toString();
      } catch {
        return null;
      }
    }

    function buildRoutes(url, mode) {
      if (mode === "direct") return [{ name: "직접 요청", requestUrl: routeBuilders.direct(url) }];
      if (mode === "allorigins") return [{ name: "AllOrigins", requestUrl: routeBuilders.allorigins(url) }];
      if (mode === "corsproxy") return [{ name: "corsproxy.io", requestUrl: routeBuilders.corsproxy(url) }];
      return [
        { name: "직접 요청", requestUrl: routeBuilders.direct(url) },
        { name: "AllOrigins", requestUrl: routeBuilders.allorigins(url) },
        { name: "corsproxy.io", requestUrl: routeBuilders.corsproxy(url) }
      ];
    }

    async function fetchTextWithFallback(pageUrl, mode) {
      const routes = buildRoutes(pageUrl, mode);
      const errors = [];

      for (const route of routes) {
        try {
          const response = await fetch(route.requestUrl, {
            method: "GET",
            credentials: "omit",
            cache: "no-store",
            redirect: "follow"
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const text = await response.text();
          if (!text || !text.trim()) throw new Error("빈 응답");
          return { text, via: route.name };
        } catch (error) {
          errors.push(`${route.name}: ${error.message}`);
        }
      }

      throw new Error(errors.join(" | "));
    }

    function parseSrcset(srcsetValue) {
      return srcsetValue
        .split(",")
        .map((entry) => entry.trim().split(/\s+/)[0])
        .filter(Boolean);
    }

    function toAbsHttpUrl(raw, base) {
      if (!raw) return null;
      const value = raw.trim();
      if (!value || value.startsWith("data:") || value.startsWith("blob:")) return null;
      try {
        const abs = new URL(value, base);
        if (!/^https?:$/i.test(abs.protocol)) return null;
        return abs.toString();
      } catch {
        return null;
      }
    }

    function collectImagesFromHtml(htmlText, pageUrl) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlText, "text/html");
      const urlMap = new Map();

      function push(raw, sourceType) {
        const abs = toAbsHttpUrl(raw, pageUrl);
        if (!abs) return;
        if (!urlMap.has(abs)) {
          urlMap.set(abs, {
            id: nextId(),
            url: abs,
            source: sourceType,
            selected: true
          });
        }
      }

      for (const img of doc.querySelectorAll("img[src]")) {
        push(img.getAttribute("src"), "img[src]");
      }
      for (const img of doc.querySelectorAll("img[srcset]")) {
        const setValue = img.getAttribute("srcset");
        for (const candidate of parseSrcset(setValue)) push(candidate, "img[srcset]");
      }
      for (const source of doc.querySelectorAll("source[srcset]")) {
        const setValue = source.getAttribute("srcset");
        for (const candidate of parseSrcset(setValue)) push(candidate, "source[srcset]");
      }
      for (const meta of doc.querySelectorAll("meta[property='og:image'], meta[name='twitter:image'], link[rel~='icon']")) {
        push(meta.getAttribute("content") || meta.getAttribute("href"), "meta/link");
      }
      for (const node of doc.querySelectorAll("[style*='background']")) {
        const style = node.getAttribute("style") || "";
        const matched = style.match(/url\((['"]?)(.*?)\1\)/i);
        if (matched && matched[2]) push(matched[2], "inline style");
      }

      return Array.from(urlMap.values());
    }

    function sanitizeFileName(name) {
      return name.replace(/[\\/:*?"<>|]+/g, "-").replace(/\s+/g, "_").slice(0, 120);
    }

    function extFromContentType(type) {
      if (!type) return "";
      if (type.includes("jpeg")) return ".jpg";
      if (type.includes("png")) return ".png";
      if (type.includes("webp")) return ".webp";
      if (type.includes("gif")) return ".gif";
      if (type.includes("svg")) return ".svg";
      if (type.includes("bmp")) return ".bmp";
      if (type.includes("avif")) return ".avif";
      return "";
    }

    function deriveFileName(imageUrl, index, extHint) {
      try {
        const parsed = new URL(imageUrl);
        const raw = parsed.pathname.split("/").pop() || `image-${index + 1}`;
        const cleaned = sanitizeFileName(decodeURIComponent(raw || `image-${index + 1}`)) || `image-${index + 1}`;
        if (/\.[a-z0-9]{2,5}$/i.test(cleaned)) return cleaned;
        return `${cleaned}${extHint || ""}`;
      } catch {
        return `image-${index + 1}${extHint || ""}`;
      }
    }

    function renderItems() {
      gridEl.innerHTML = "";
      metaEl.textContent = `${imageItems.length}개`;
      emptyStateEl.style.display = imageItems.length ? "none" : "grid";
      const selectedCount = imageItems.filter((item) => item.selected).length;
      if (imageItems.length) metaEl.textContent = `${imageItems.length}개 (선택 ${selectedCount}개)`;

      for (let i = 0; i < imageItems.length; i += 1) {
        const item = imageItems[i];
        const card = document.createElement("article");
        card.className = "card";
        card.innerHTML = `
          <div class="thumb-wrap">
            <img alt="preview image" loading="lazy" referrerpolicy="no-referrer" />
            <div class="thumb-fallback" hidden>미리보기를 불러올 수 없습니다.</div>
          </div>
          <div class="card-body">
            <label class="check-row">
              <input type="checkbox" data-id="${item.id}">
              <span>이미지 ${i + 1}</span>
            </label>
            <div class="source-tag">${item.source}</div>
            <div class="path">${item.url}</div>
          </div>
        `;

        const imgEl = card.querySelector("img");
        const fallbackEl = card.querySelector(".thumb-fallback");
        const checkboxEl = card.querySelector("input[type='checkbox']");
        imgEl.src = item.url;
        imgEl.addEventListener("error", () => {
          imgEl.hidden = true;
          fallbackEl.hidden = false;
        });
        checkboxEl.checked = item.selected;
        checkboxEl.addEventListener("change", () => {
          item.selected = checkboxEl.checked;
          const count = imageItems.filter((one) => one.selected).length;
          metaEl.textContent = `${imageItems.length}개 (선택 ${count}개)`;
        });
        gridEl.append(card);
      }
    }

    async function fetchBlobWithFallback(targetUrl, mode) {
      const routes = buildRoutes(targetUrl, mode);
      const errors = [];

      for (const route of routes) {
        try {
          const response = await fetch(route.requestUrl, {
            method: "GET",
            credentials: "omit",
            cache: "no-store",
            redirect: "follow"
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const blob = await response.blob();
          if (!blob || blob.size === 0) throw new Error("빈 파일");
          return { blob, via: route.name };
        } catch (error) {
          errors.push(`${route.name}: ${error.message}`);
        }
      }

      throw new Error(errors.join(" | "));
    }

    function saveBlob(blob, filename) {
      const blobUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = blobUrl;
      a.download = filename;
      document.body.append(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(blobUrl), 4000);
    }

    async function scanImages() {
      const pageUrl = normalizeHttpUrl(urlInput.value);
      if (!pageUrl) {
        setStatus("유효한 URL을 입력하세요. 예: https://example.com", "warn");
        return;
      }
      if (!agreeInput.checked) {
        setStatus("권한 확인 체크를 먼저 해주세요.", "warn");
        return;
      }

      setBusy(true);
      setStatus("페이지를 불러오는 중...");
      imageItems = [];
      renderItems();

      try {
        const mode = proxySelect.value;
        const fetched = await fetchTextWithFallback(pageUrl, mode);
        const found = collectImagesFromHtml(fetched.text, pageUrl);
        imageItems = found;
        renderItems();
        setStatus(`완료: ${found.length}개 이미지 후보를 찾았습니다. (수집 경로: ${fetched.via})`);
      } catch (error) {
        imageItems = [];
        renderItems();
        setStatus(`수집 실패: ${error.message}`, "error");
      } finally {
        setBusy(false);
      }
    }

    async function downloadSelectedIndividually() {
      const selected = imageItems.filter((item) => item.selected);
      if (!selected.length) {
        setStatus("선택된 이미지가 없습니다.", "warn");
        return;
      }
      if (!agreeInput.checked) {
        setStatus("권한 확인 체크를 먼저 해주세요.", "warn");
        return;
      }

      setBusy(true);
      let success = 0;
      let fail = 0;
      const mode = proxySelect.value;

      for (let i = 0; i < selected.length; i += 1) {
        const item = selected[i];
        setStatus(`개별 다운로드 중... ${i + 1}/${selected.length}`);
        try {
          const fetched = await fetchBlobWithFallback(item.url, mode);
          const ext = extFromContentType(fetched.blob.type);
          const fileName = deriveFileName(item.url, i, ext);
          saveBlob(fetched.blob, fileName);
          success += 1;
        } catch {
          fail += 1;
        }
      }

      setBusy(false);
      if (fail) {
        setStatus(`완료: ${success}개 성공, ${fail}개 실패. 실패 항목은 CORS/서버 차단일 수 있습니다.`, "warn");
      } else {
        setStatus(`완료: ${success}개 다운로드 성공.`);
      }
    }

    async function downloadSelectedAsZip() {
      const selected = imageItems.filter((item) => item.selected);
      if (!selected.length) {
        setStatus("선택된 이미지가 없습니다.", "warn");
        return;
      }
      if (!agreeInput.checked) {
        setStatus("권한 확인 체크를 먼저 해주세요.", "warn");
        return;
      }
      if (!window.JSZip) {
        setStatus("JSZip 로딩 실패로 ZIP 기능을 사용할 수 없습니다.", "error");
        return;
      }

      setBusy(true);
      const mode = proxySelect.value;
      const zip = new JSZip();
      let added = 0;
      let skipped = 0;

      for (let i = 0; i < selected.length; i += 1) {
        const item = selected[i];
        setStatus(`ZIP 생성 중... ${i + 1}/${selected.length}`);
        try {
          const fetched = await fetchBlobWithFallback(item.url, mode);
          const ext = extFromContentType(fetched.blob.type);
          const fileName = deriveFileName(item.url, i, ext);
          zip.file(fileName, fetched.blob);
          added += 1;
        } catch {
          skipped += 1;
        }
      }

      if (!added) {
        setBusy(false);
        setStatus("ZIP 실패: 저장 가능한 이미지가 없습니다.", "error");
        return;
      }

      const zipBlob = await zip.generateAsync({ type: "blob" });
      const stamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
      saveBlob(zipBlob, `page-images-${stamp}.zip`);
      setBusy(false);

      if (skipped) {
        setStatus(`ZIP 저장 완료: ${added}개 포함, ${skipped}개 제외됨.`, "warn");
      } else {
        setStatus(`ZIP 저장 완료: ${added}개 포함.`);
      }
    }

    function toggleSelection(next) {
      if (!imageItems.length) return;
      for (const item of imageItems) item.selected = next;
      renderItems();
      const selectedCount = imageItems.filter((item) => item.selected).length;
      setStatus(`선택 상태 변경: ${selectedCount}개 선택됨.`);
    }

    scanBtn.addEventListener("click", scanImages);
    urlInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") scanImages();
    });
    selectAllBtn.addEventListener("click", () => toggleSelection(true));
    clearSelectBtn.addEventListener("click", () => toggleSelection(false));
    downloadSelectedBtn.addEventListener("click", downloadSelectedIndividually);
    downloadZipBtn.addEventListener("click", downloadSelectedAsZip);

    setStatus("준비됨");
    renderItems();
  </script>
</body>
</html>
